def estimate_N_star_from_merged_ob(ob_df, side='Buy', N_target=100):
    """
    Estimate optimal order size N* using pre-merged order book data with embedded trades.

    Parameters:
    - ob_df: DataFrame with 'trades', 'bid0', 'ask0', 'bidSize0', 'askSize0',
             optionally 'bidSize0_prev', 'askSize0_prev'
    - side: 'Buy' or 'Sell'
    - N_target: target executed volume

    Returns:
    - dict of estimated parameters and N* (simple and strict versions)
    """

    ob_df = ob_df.sort_values('streamTime').reset_index(drop=True)

    # Ensure prev size columns exist
    if 'bidSize0_prev' not in ob_df.columns or 'askSize0_prev' not in ob_df.columns:
        ob_df['bidSize0_prev'] = ob_df['bidSize0'].shift(1)
        ob_df['askSize0_prev'] = ob_df['askSize0'].shift(1)
        ob_df.loc[0, 'bidSize0_prev'] = ob_df.loc[0, 'bidSize0']
        ob_df.loc[0, 'askSize0_prev'] = ob_df.loc[0, 'askSize0']

    def estimate_mu(row):
        price_col = 'bid0' if side == 'Buy' else 'ask0'
        trades = row['trades']
        if side == 'Buy':
            relevant = [t for t in trades if t['price'] <= row[price_col]]
        else:
            relevant = [t for t in trades if t['price'] >= row[price_col]]
        return sum(t['size'] for t in relevant)

    def estimate_delta(row):
        size_col = 'bidSize0' if side == 'Buy' else 'askSize0'
        price_col = 'bid0' if side == 'Buy' else 'ask0'
        prev_size = row[size_col + '_prev']
        curr_size = row[size_col]
        trades = row['trades']
        if side == 'Buy':
            relevant = [t for t in trades if t['price'] <= row[price_col]]
        else:
            relevant = [t for t in trades if t['price'] >= row[price_col]]
        traded = sum(t['size'] for t in relevant)
        return max(prev_size - curr_size - traded, 0)

    def estimate_lambda(row):
        size_col = 'bidSize0' if side == 'Buy' else 'askSize0'
        price_col = 'bid0' if side == 'Buy' else 'ask0'
        prev_size = row[size_col + '_prev']
        curr_size = row[size_col]
        trades = row['trades']
        if side == 'Buy':
            relevant = [t for t in trades if t['price'] <= row[price_col]]
        else:
            relevant = [t for t in trades if t['price'] >= row[price_col]]
        traded = sum(t['size'] for t in relevant)
        return max(curr_size - prev_size - traded, 0)

    ob_df['mu_volume'] = ob_df.apply(estimate_mu, axis=1)
    ob_df['delta_volume'] = ob_df.apply(estimate_delta, axis=1)
    ob_df['lambda_volume'] = ob_df.apply(estimate_lambda, axis=1)

    total_time = (ob_df['streamTime'].iloc[-1] - ob_df['streamTime'].iloc[0]).total_seconds()
    lambda_rate = ob_df['lambda_volume'].sum() / total_time
    mu_rate = ob_df['mu_volume'].sum() / total_time
    delta_rate = ob_df['delta_volume'].sum() / total_time

    denominator = mu_rate + delta_rate - lambda_rate
    if denominator <= 0 or np.isnan(denominator):
        raise ValueError(f"Invalid queue state: denominator = {denominator:.4f}")
    expected_z = lambda_rate / denominator

    N_star_simple = compute_optimal_order_size_simple(expected_z, N_target)
    N_star_strict = compute_optimal_order_size_strict(lambda_rate, mu_rate, delta_rate, N_target)

    return {
        'lambda': lambda_rate,
        'mu': mu_rate,
        'delta': delta_rate,
        'expected_z': expected_z,
        'N_star_simple': N_star_simple,
        'N_star_strict': N_star_strict
    }
